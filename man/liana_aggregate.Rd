% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/liana_aggregate.R
\name{liana_aggregate}
\alias{liana_aggregate}
\title{Function to Aggregate CCC Method Results}
\usage{
liana_aggregate(
  liana_res,
  resource = NULL,
  set_cap = "max",
  cap = NULL,
  get_ranks = TRUE,
  get_agrank = TRUE,
  .score_mode = .score_specs,
  verbose = TRUE,
  join_cols = NULL,
  ...
)
}
\arguments{
\item{liana_res}{LIANA results}

\item{resource}{If methods are ran with multiple resources, the name of the
resource of interest needs to be provided
*Note* if a name is not provided, the first results based on the first
resource in the list will be returned}

\item{set_cap}{Function used to set ranked cap (i.e. the value that is
assigned to interactions with NA for scores);
By default, this is set to "max", which is the maximum number of interactions
obtained by the methods; Some methods return all possible ligand-receptor
combinations for each possible source and target cell pair - i.e. the
known universe of all possible interactions (based on the CCC resource)}

\item{cap}{A cap can for all methods can also be manually set, then the top X
interactions, based on the `specificity` scores for each method will be
returned and the ranking will be carried out solely on them}

\item{get_ranks}{boolean, whether to return consensus ranks for methods}

\item{get_agrank}{boolean, whether to return aggregate rank using the
`RobustRankAggreg` package.}

\item{.score_mode}{defines the way that the methods would be aggragate.
By default, we use the score of each method which reflects specificity
(if available), if not e.g. the case of SCA we use it's sole scoring function.
This aggregation is by default done on the basis of the list returns by
`.score_mode`. Alternatively, one could pass `.score_housekeep` to obtain an
aggragate of the housekeeping interactions of each `external` LIANA++ method.}

\item{join_cols}{columns by which different method results will be joined.
NULL by default, and automatically will handle the columns depending on the
methods used.}

\item{...}{
  Arguments passed on to \code{\link[RobustRankAggreg:aggregateRanks]{RobustRankAggreg::aggregateRanks}}
  \describe{
    \item{\code{glist}}{list of element vectors, the order of the
  vectors is used as the ranking.}
    \item{\code{rmat}}{the rankings in matrix format. The glist is
  by default converted to this format.}
    \item{\code{N}}{the number of ranked elements, important when
  using only top-k ranks, by default it is calculated as
  the number of unique elements in the input.}
    \item{\code{method}}{rank aggregation method, by defaylt
  \code{'RRA'}, other options are \code{'min'},
  \code{'geom.mean'}, \code{'mean'}, \code{'median'} and
  \code{'stuart'}}
    \item{\code{full}}{indicates if the full rankings are given,
  used if the the sets of ranked elements do not match
  perfectly}
    \item{\code{exact}}{indicator showing if exact p-value will be
  calculated based on rho score (Default: if number of
  lists smaller than 10, exact is used)}
    \item{\code{topCutoff}}{a vector of cutoff values used to limit
  the number of elements in the input lists elements do not
  match perfectly}
  }}
}
\value{
Tibble with the interaction results and ranking for each method
}
\description{
Function to Aggregate CCC Method Results
}
\details{
set_cap is the name of the name of a function that is to be executed
  on a vector representing the number of rows in the results for each method,
  by default this is set to \link{base::max}, but any other function that
  works with vectors could be passed - e.g. min, mean, etc.

This function also decomplexifies any complex present in the CellChat results
which returns complexes by default
}
\examples{
liana_path <- system.file(package = "liana")
# load testdata
testdata <- readRDS(file.path(liana_path , "testdata", "input", "testdata.rds"))
# run liana
liana_res <- liana_wrap(testdata, method=c("sca", "natmi"))
# aggregate results from multiple methods
liana_res <- liana_aggregate(liana_res)
}
