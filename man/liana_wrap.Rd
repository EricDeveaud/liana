% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/liana_wrapper.R
\name{liana_wrap}
\alias{liana_wrap}
\title{LIANA wrapper function}
\usage{
liana_wrap(
  sce,
  method = c("natmi", "connectome", "logfc", "sca", "cellphonedb"),
  resource = c("Consensus"),
  idents_col = NULL,
  external_resource,
  min_cells = 5,
  verbose = TRUE,
  assay = NULL,
  .simplify = TRUE,
  cell.adj = NULL,
  base = NULL,
  ...
)
}
\arguments{
\item{sce}{`SingleCellExperiment` object or `SeuratObject`}

\item{method}{method(s) to be run via liana}

\item{resource}{resource(s) to be used by the methods (`Consensus` by default), Use `all` to run all resources in one go),
or `custom` to run liana_wrap with an appropriately formatted custom resource, passed via `exernal_resource`}

\item{idents_col}{the cell identities/labels to be used. By default set to NULL, and will used the active
Idents or colLabels from the seurat_object or SCE, respectively.}

\item{external_resource}{external resource in OmniPath tibble format}

\item{min_cells}{minimum cell per cell identity to be considered for analysis}

\item{verbose}{logical whether to output messages and warnings (`TRUE` by default)}

\item{assay}{assay to be used by Seurat, by default set to `NULL` and will use the DefaultAssay.}

\item{.simplify}{if methods are run with only 1 resource, return a list
of tibbles for each method (default), rather than a list of lists with
method-resource combinations}

\item{cell.adj}{cell adjacency tibble/dataframe /w weights by which we will
`multiply` the relevant columns. Any cell pairs with a weights of 0 will be
filtered out.
Note that if working with LIANA's default methods, we suggest weights >= 0 & =< 1.
This ensure that all methods' score will be meaningfully weighed without
changing the interpretation of their scores, thus allow one to filter SCA,
rank NATMI, etc.}

\item{base}{Default to NULL (i.e. log2-transformation is assumed
for SCE, and log-tranformation for Seurat). This is a requred step for the
calculation of the logFC method - ensures that any other preprocessing of
the counts is preserved. One could also pass `NaN` if they wish to use the
counts stored in the counts assay/slot, or any other number according to the
base that was used for log-tranformation.}

\item{...}{
  Arguments passed on to \code{\link[=liana_defaults]{liana_defaults}}
  \describe{
    \item{\code{liana_pipe.params}}{list of Parameters passed to NATMI \code{\link{liana_pipe}}}
    \item{\code{liana_call.params}}{list of Parameters passed to NATMI \code{\link{liana_call}}}
    \item{\code{cellchat.params}}{list of Parameters passed to CellChat \code{\link{call_cellchat}}}
    \item{\code{squidpy.params}}{list of Parameters passed to Squidpy \code{\link{call_squidpy}}}
    \item{\code{call_connectome.params}}{list of Parameters passed to Connectome \code{\link{call_connectome}}}
    \item{\code{call_italk.params}}{list of Parameters passed to iTALK \code{\link{call_italk}}}
    \item{\code{call_natmi.params}}{list of Parameters passed to NATMI \code{\link{call_natmi}}}
    \item{\code{call_sca.params}}{list of Parameters passed to SingleCellSignalR \code{\link{call_sca}}}
    \item{\code{cellphonedb.params}}{list of Parameters passed to liana's internal
cellphonedb implementation \code{\link{cellphonedb_score}}}
    \item{\code{natmi.params}}{list of Parameters passed to liana's internal
edge_specificity implementation \code{\link{natmi_score}}}
    \item{\code{sca.params}}{list of Parameters passed to liana's internal
LRScore implementation \code{\link{sca_score}}}
    \item{\code{connectome.params}}{list of Parameters passed to liana's internal
connectome's weight_sc implementation \code{\link{connectome_score}}}
    \item{\code{cytotalk.params}}{list of Parameters passed to liana's internal
crosstalk scores implementation \code{\link{cytotalk_score}}}
    \item{\code{logfc.params}}{list of Parameters passed to liana's internal
logFC implementation \code{\link{logfc_score}}}
    \item{\code{permutation.params}}{list of parameters passed to permutation methods}
    \item{\code{expr_prop}}{minimum proportion of gene expression per cell type (0.1 by default).
This is further applied at a method-specific level - it is not applied to
 Connectome and Cytotalk, as these methods calculate/normalize the score (or
 statistics used in their scores) across all cell types or cell type pairs.}
    \item{\code{complex_policy}}{policy how to account for the presence of complexes.}
    \item{\code{seed}}{random seed integer}
    \item{\code{parallelize}}{whether to parallelize cellphonedb-like}
    \item{\code{workers}}{number of workers to be called}
    \item{\code{assay.type}}{- the type of data to be used to calculate the means
(logcounts by default), available options are: "counts" and "logcounts"}
  }}
}
\value{
A list of method-resource results - i.e. provided resources are run
with each method
If only one resource is selected, a single tibble (with results for that
 resource) will be returned for each of the selected methods
}
\description{
LIANA wrapper function
}
\details{
LIANA wrapper method that can be used to call each method with
 a given set of intercellular resources from the OmniPath universe.
 Please see `liana_defaults()` for more information about the
 default parameters passed used by `liana_wrap`, if you wish to modify them.
}
\examples{
liana_path <- system.file(package = "liana")
# load testdata
testdata <- readRDS(file.path(liana_path , "testdata", "input", "testdata.rds"))
# run only 2 methods from liana
liana_res <- liana_wrap(testdata, method = c('cellphonedb', 'sca'),
                        resource = 'Consensus', # default resource
                        # example run with *only* 2 permutations for cpdb
                        permutation.params = list(nperms = 2))
}
