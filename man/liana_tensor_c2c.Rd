% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/liana_tensor.R
\name{liana_tensor_c2c}
\alias{liana_tensor_c2c}
\title{Wrapper function to run `cell2cell_tensor` with LIANA output.}
\usage{
liana_tensor_c2c(
  sce = NULL,
  context_df_dict = NULL,
  score_col = "LRscore",
  how = "inner",
  lr_fill = NaN,
  cell_fill = NaN,
  lr_sep = "^",
  context_order = NULL,
  sort_elements = TRUE,
  device = NULL,
  rank = NULL,
  seed = 1337,
  upper_rank = 25,
  runs = 3,
  init = "svd",
  build_only = FALSE,
  factors_only = TRUE,
  conda_env = NULL,
  use_available = FALSE,
  verbose = TRUE,
  inplace = TRUE,
  sender_col = "source",
  receiver_col = "target",
  ligand_col = "ligand.complex",
  receptor_col = "receptor.complex",
  ...
)
}
\arguments{
\item{sce}{SingleCellExperiment with `context_df_dict` - i.e. liana results
per context (sample) stored at `sce@metadata$liana_res`}

\item{context_df_dict}{Dictionary (named list) containing a dataframe for
each context. The dataframe must contain columns containing sender (source) cells,
receiver (target) cells, ligands, receptors, and communication scores, separately.
Keys are context names and values are dataframes. NULL by default.
If not NULL will be used instead of `sce@metadata$liana_res`.}

\item{score_col}{Name of the column containing the communication scores in
all context dataframes.}

\item{how}{Approach to consider cell types and genes present across multiple contexts.
- 'inner' : Considers only cell types and LR pairs that are present in all contexts (intersection).
- 'outer' : Considers all cell types and LR pairs that are present across contexts (union).
- 'outer_lr' : Considers only cell types that are present in all contexts (intersection),
 while all LR pairs that are present across contexts (union).
- 'outer_cells' : Considers only LR pairs that are present in all contexts (intersection),
 while all cell types that are present across contexts (union).}

\item{lr_fill}{Value to fill communication scores when a ligand-receptor
pair is not present across all contexts. (NaN by default)}

\item{cell_fill}{Value to fill communication scores when a cell is not
present across all ligand-receptor pairs or all contexts. (NaN by default)}

\item{lr_sep}{Separation character to join ligands and receptors into a
LR pair name. ('^' by Default)}

\item{context_order}{List used to sort the contexts when building the tensor.
Elements must be all elements in `names(context_df_dict)`. (NULL by default)}

\item{sort_elements}{Whether alphabetically sorting elements in the
InteractionTensor. The Context Dimension is not sorted if a
'context_order' list is provided. (TRUE by default).}

\item{device}{Device to use when backend is pytorch.
Options are: ['cpu', 'cuda:0', None]. NULL by Default}

\item{rank}{Ranks for the Tensor Factorization (number of factors to deconvolve the original tensor).
If NULL, then rank selection is performed using the `elbow_rank_selection` function.}

\item{seed}{Random seed integer}

\item{upper_rank}{Upper bound of ranks to explore with the elbow analysis.}

\item{runs}{Number of tensor factorization performed for a given rank.
Each factorization varies in the seed of initialization. Consider increasing
the number of runs, in order to obtain a more robust rank estimate.}

\item{init}{Initialization method for computing the Tensor Factorization.
{‘svd’, ‘random’}}

\item{build_only}{Whether to only return a tensor instance, without rank
selection and no factorization.}

\item{factors_only}{whether to return only the factors after factorization}

\item{conda_env}{name of existing conda environment}

\item{use_available}{whether to use c2c if available in current env.
False by default.}

\item{verbose}{verbosity logical}

\item{inplace}{logical (TRUE by default) if liana results are to be saved
to the SingleCellExperiment object (`sce@metadata$liana_res`)}

\item{sender_col}{Name of the column containing the sender cells in all context
dataframes.}

\item{receiver_col}{Name of the column containing the receiver cells in all context
dataframes.}

\item{ligand_col}{Name of the column containing the ligands in all context
dataframes.}

\item{receptor_col}{Name of the column containing the receptors in all context
dataframes.}

\item{...}{Dictionary containing keyword arguments for the c2c.compute_tensor_factorization function.
The function deals with `random_state` (seed) and `rank` internally.}
}
\value{
an instance of the cell2cell.tensor.BaseTensor class (via reticulate).
If build_only is TRUE, then no rank selection or tensor decomposition is returned.
Otherwise, returns a tensor with factorization results.
}
\description{
Wrapper function to run `cell2cell_tensor` with LIANA output.
}
\details{
This function servers as a one-liner wrapper to the tensor factorisation
method described in \href{https://www.nature.com/articles/s41467-022-31369-2}{tensor_cell2cell}.
We refer the user to the publication and \href{https://earmingol.github.io/cell2cell/tutorials/ASD/01-Tensor-Factorization-ASD/}{tensor_cell2cell tutorial page}
made by the authors. Logically, one should cite cell2cell's paper if their
method was used via LIANA.
}
